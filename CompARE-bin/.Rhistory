}
#' and calculated from the probability of occurrence of the respective events.
#' This function allows to calculate the minimum correlation that this typology of variables can experience.
#'
#'
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#' @details upper_corr returns a numeric value negated bounded between 0 and 1.
#' The probabilities of the occurrence of events must be defined by the open interval of (0.1).
#' @return Returns the upper correlation threshold that can be set by the compost binarius event.
#' @export
upper_corr <- function(p_e1,p_e2){
if(p_e1 < 0 || p_e1 > 1){
stop("p.E1 numeric value are not allowed")
}else if(p_e2 < 0 || p_e2 > 1){
stop("p.E2 numeric value are not allowed")
}else{
upper_corr <- min(  sqrt( ( p_e1/ (1-p_e1) )/( p_e2/ (1-p_e2) ) ), sqrt((p_e2/(1-p_e2))/(p_e1/(1-p_e1)) ) )
return(upper_corr)
}
}
prob_ce_1 <- prob_ce(0.54,0.4,0.5)
prob_ce_2 <- prob_ce(0.4,0.54,0.5)
prob_ce_1 <- prob_ce(0.54,0.4,0.3)
lower_corr(0.54,0.4)
upper_corr(0.54,0.4)
prob_ce_1 <- prob_ce(0.54,0.4,0.3)
#'
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#' @param rho numeric parameter, Pearson correlation between E1 i E2
#' @details Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' @return Returns the probability of a union of two events
#' @export
#'
prob_ce <- function(p_e1, p_e2, rho){
if(p_e1 < 0 || p_e1 > 1){
stop("p.E1 numeric value are not allowed")
}else if(p_e2 < 0 || p_e2 > 1){
stop("p.E2 numeric value are not allowed")
}else if(rho > lower_corr(p_e1,p_e2) && rho < upper_corr(p_e1,p_e2)){
stop("rho numeric value are not allowed")
}else{
prob_ce <- 1- (1-p_e1)*(1-p_e2)*( 1+ rho*sqrt(p_e1*p_e2/((1-p_e1)*(1-p_e2))))
return(prob_ce)
}
}
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
p_e1
p_e1 = 0.54
p_e2 = 0.4
rho = 0.3
rho > lower_corr(p_e1,p_e2) && rho < upper_corr(p_e1,p_e2)
#'
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#' @param rho numeric parameter, Pearson correlation between E1 i E2
#' @details Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' @return Returns the probability of a union of two events
#' @export
#'
prob_ce <- function(p_e1, p_e2, rho){
if(p_e1 < 0 || p_e1 > 1){
stop("p.E1 numeric value are not allowed")
}else if(p_e2 < 0 || p_e2 > 1){
stop("p.E2 numeric value are not allowed")
}else if(rho < lower_corr(p_e1,p_e2) && rho > upper_corr(p_e1,p_e2)){
stop("rho numeric value are not allowed")
}else{
prob_ce <- 1- (1-p_e1)*(1-p_e2)*( 1+ rho*sqrt(p_e1*p_e2/((1-p_e1)*(1-p_e2))))
return(prob_ce)
}
}
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
prob_ce_1 <- prob_ce(0.54,0.4,0.2)
prob_ce_2 <- prob_ce(0.4,0.54,0.2)
prob_ce_3 <- prob_ce(0.4,0.54,0.2)
prob_ce_4 <- prob_ce(0.6,0.3,0.2)
prob_ce_1
prob_ce_4
prob_ce_4 <- prob_ce(0.6,0.3,0.6)
prob_ce_4
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
prob_ce_1
prob_ce(0.2,0.4,5)
lower_corr(0.2,0.4)
uower_corr(0.2,0.4)
upper_corr(0.2,0.4)
prob_ce(0.2,0.4,5)
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
prob_ce(0.2,0.4,5)
#'
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#' @param rho numeric parameter, Pearson correlation between E1 i E2
#' @details Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' @return Returns the probability of a union of two events
#' @export
#'
prob_ce <- function(p_e1, p_e2, rho){
if(p_e1 < 0 || p_e1 > 1){
stop("p.E1 numeric value are not allowed")
}else if(p_e2 < 0 || p_e2 > 1){
stop("p.E2 numeric value are not allowed")
}else if(rho < lower_corr(p_e1,p_e2) && rho > upper_corr(p_e1,p_e2)){
stop("rho numeric value are not allowed")
}else{
prob_ce <- 1- (1-p_e1)*(1-p_e2)*( 1+ rho*sqrt(p_e1*p_e2/((1-p_e1)*(1-p_e2))))
return(prob_ce)
}
}
prob_ce(0.2,0.4,5)
rho < lower_corr(p_e1,p_e2)
rho
lower_corr(p_e1,p_e2)
#'
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#' @param rho numeric parameter, Pearson correlation between E1 i E2
#' @details Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' @return Returns the probability of a union of two events
#' @export
#'
prob_ce <- function(p_e1, p_e2, rho){
if(p_e1 < 0 || p_e1 > 1){
stop("p.E1 numeric value are not allowed")
}else if(p_e2 < 0 || p_e2 > 1){
stop("p.E2 numeric value are not allowed")
}else if(rho > lower_corr(p_e1,p_e2) && rho < upper_corr(p_e1,p_e2)){
stop("rho numeric value are not allowed")
}else{
prob_ce <- 1- (1-p_e1)*(1-p_e2)*( 1+ rho*sqrt(p_e1*p_e2/((1-p_e1)*(1-p_e2))))
return(prob_ce)
}
}
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
lower_corr(0.54,0.4)
upper_corr(0.54,0.4)
ce_1 <- prob_ce(0.54,0.4,0.2)
prob_
prob_ce_1 <- prob_ce(0.54,0.4,0.2)
#'
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#' @param rho numeric parameter, Pearson correlation between E1 i E2
#' @details Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' @return Returns the probability of a union of two events
#' @export
#'
prob_ce <- function(p_e1, p_e2, rho){
if(p_e1 < 0 || p_e1 > 1){
stop("p.E1 numeric value are not allowed")
}else if(p_e2 < 0 || p_e2 > 1){
stop("p.E2 numeric value are not allowed")
}else if(rho < lower_corr(p_e1,p_e2)  ||  rho > upper_corr(p_e1,p_e2)){
stop("rho numeric value are not allowed")
}else{
prob_ce <- 1- (1-p_e1)*(1-p_e2)*( 1+ rho*sqrt(p_e1*p_e2/((1-p_e1)*(1-p_e2))))
return(prob_ce)
}
}
prob_ce_1 <- prob_ce(0.54,0.4,0.2)
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
prob_ce_1
prob_ce_4
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
length(prob_ce_1)
?length
eff_a = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "Diff")
eff_b = effect_ce(0.3,0.4,0.2,0.5,0.32)
eff_c = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "OR")
eff_d = effect_ce(0.65,0.23,0.42,0.15,0.32, type = "OR")
eff_e = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "RR")
eff_f = effect_ce(0.43,0.87,0.32,0.25,0.23, type = "RR")
library(CBE)
eff_a = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "Diff")
eff_b = effect_ce(0.3,0.4,0.2,0.5,0.32)
eff_c = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "OR")
eff_d = effect_ce(0.65,0.23,0.42,0.15,0.32, type = "OR")
eff_e = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "RR")
eff_a = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "diff")
eff_b = effect_ce(0.3,0.4,0.2,0.5,0.32)
eff_c = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "or")
eff_d = effect_ce(0.65,0.23,0.42,0.15,0.32, type = "or")
eff_e = effect_ce(0.3,0.4,0.2,0.5,0.32, type = "rr")
eff_f = effect_ce(0.43,0.87,0.32,0.25,0.23, type = "rr")
eff$diff
eff_a$diff
eff_b$diff
eff_c$diff
eff_d$diff
ss_h = sample_size_ce(0.2,0.3,0.1,0.2,"or",0.4, 0.05,0.2,"Variance")
0:1
seq(0,1, 0.1)
seq(0,1, 0.01)
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
library(testthat)
library(CBE)
#test_check("CBE")
source("tests/testthat/test-CBEval1.R")
test_file("tests/testthat/test-CBEval1.R")
prob_ce(0.3,0.2,0.3)
prob_ce(c(0.3,0.2,0.3))
auto_test()
auto_test("C:\Users.raquel.rovira\Desktop\CBE")
getwd()
auto_test("C:/Users/raquel.rovira/Desktop/CBE")
auto_test("C:/Users/raquel.rovira/Desktop/CBE")
getwd()
1:0.01
0.01:1
#'
#' @return Returns the desired effect of the composite binary event
#' @details  Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' To calculate this confidence interval you can use lower_corr and upper_corr functions that you can find in this package.
#' For defect, if you don't specify the type of effect you want to obtain,
#' it calculates the difference in proportions.
#' @references
#' @author Raquel Rovira Salvat
effect_ce <- function(p0_e1, p0_e2, p1_e1, p1_e2, rho, type = "diff"){
if(p0_e1 < 0 || p0_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p0_e2 < 0 || p0_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else if(p1_e1 < 0 || p1_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p1_e2 < 0 || p1_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else if(rho < max(c(lower_corr(p0_e1,p0_e2),lower_corr(p1_e1,p1_e2)))  ||  rho > max(c(upper_corr(p0_e1,p0_e2),upper_corr(p1_e1,p1_e2)))){
stop("The correlations of events must be in the correct interval")
}else if(type != "rr" && type != "diff" && type != "or"){
stop("You have to choose between odds ratio, relative risk or difference in proportions")
}
out_e1 = round(1- (1-p1_e1)*(1-p1_e2)*( 1+ rho*sqrt(p1_e1*p1_e2/((1-p1_e1)*(1-p1_e2)))),2)
out_e2 = round(1- (1-p0_e1)*(1-p0_e2)*( 1+ rho*sqrt(p0_e1*p0_e2/((1-p0_e1)*(1-p0_e2)))),2)
if(type == "diff"){
effect = out_e1 - out_e2
diff <- c(out_e1,out_e2,effect)
effect_ce <- as.data.frame(diff)
}else if(type == "rr"){
effect = out_e1 / out_e2
rr <- c(out_e1,out_e2,effect)
effect_ce <- as.data.frame(rr)
}else if(type == "or"){
O10= p0_e1/(1-p0_e1)
O20= p0_e2/(1-p0_e2)
or1 = (p1_e1/p1_e2)/(p0_e1/p0_e2)
or2 = (p1_e2/p1_e1)/(p0_e2/p0_e1)
effect = ((O10*or1+1)*(O20*or2+1)-1-rho*sqrt(or1*or2*O10*O20))*(1+rho*sqrt(O10*O20))/
(((1+O10)*(1+O20)-1-rho*sqrt(O10*O20))*(1+rho*sqrt(or1*or2*O10*O20)))
or <- c(out_e1,out_e2,effect)
effect_ce <- as.data.frame(or)
}
rownames(effect_ce) <- c("Effect E1","Effect E2", "Effect CE")
return(effect_ce)
}
#'
#' @return Returns the desired effect of the composite binary event
#' @details  Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' To calculate this confidence interval you can use lower_corr and upper_corr functions that you can find in this package.
#' For defect, if you don't specify the type of effect you want to obtain,
#' it calculates the difference in proportions.
#' @references
#' @author Raquel Rovira Salvat
effect_ce <- function(p0_e1, p0_e2, p1_e1, p1_e2, rho, type = "diff"){
if(p0_e1 < 0 || p0_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p0_e2 < 0 || p0_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else if(p1_e1 < 0 || p1_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p1_e2 < 0 || p1_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else if(rho < max(c(lower_corr(p0_e1,p0_e2),lower_corr(p1_e1,p1_e2)))  ||  rho > max(c(upper_corr(p0_e1,p0_e2),upper_corr(p1_e1,p1_e2)))){
stop("The correlations of events must be in the correct interval")
}else if(type != "rr" && type != "diff" && type != "or"){
stop("You have to choose between odds ratio, relative risk or difference in proportions")
}
if(type == "diff"){
effect = prob_ce(p1_e1,p1_e2,rho) - prob_ce(p0_e1,p0_e2,rho)
diff <- c(out_e1,out_e2,effect)
effect_ce <- as.data.frame(diff)
}else if(type == "rr"){
effect = prob_ce(p1_e1,p1_e2,rho)/prob_ce(p0_e1,p0_e2,rho)
rr <- c(out_e1,out_e2,effect)
effect_ce <- as.data.frame(rr)
}else if(type == "or"){
O10= p0_e1/(1-p0_e1)
O20= p0_e2/(1-p0_e2)
or1 = (p1_e1/p1_e2)/(p0_e1/p0_e2)
or2 = (p1_e2/p1_e1)/(p0_e2/p0_e1)
effect = ((O10*or1+1)*(O20*or2+1)-1-rho*sqrt(or1*or2*O10*O20))*(1+rho*sqrt(O10*O20))/
(((1+O10)*(1+O20)-1-rho*sqrt(O10*O20))*(1+rho*sqrt(or1*or2*O10*O20)))
or <- c(out_e1,out_e2,effect)
effect_ce <- as.data.frame(or)
}
rownames(effect_ce) <- c("Effect E1","Effect E2", "Effect CE")
return(effect_ce)
}
#' @param unpooled Variance class used in the calculation of the sample size
#' @return Return the sample measurement to be used based on the calculated parameters of the combined variable.
#' The entry parameters representing the probability of the events taking place are limited between 0 and 1,
#'  without including both values. Pearson's correlation must be within the confidence interval allowed
#'  by the combined variable according to the probabilities given. By default, if the type of effect
#'  with which the resulting large sample is to be associated is not specified,
#'  the difference in proportions is used. When specifying the levels of alpha and beta meaning,
#'  they may not be higher than 1, as well as the following type of variance that is desired to be used
#'  in the calculation of the sample size.
#' @export
sample_size_ce <- function(p0_e1,p0_e2,p1_e1,p1_e2,effect_ce  = "diff",rho, alpha = 0.05, beta = 0.2, unpooled = "unpooled Variance"){
if(p0_e1 < 0 || p0_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p0_e2 < 0 || p0_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else if(p1_e1 < 0 || p1_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p1_e2 < 0 || p1_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else if(effect_ce != "diff" && effect_ce != "rr" && effect_ce != "or"){
stop("You have to choose between odds ratio, relative risk or difference in proportions")
}else if(rho < max(c(lower_corr(p0_e1,p0_e2),lower_corr(p1_e1,p1_e2)))  ||  rho > max(c(upper_corr(p0_e1,p0_e2),upper_corr(p1_e1,p1_e2)))){
stop("The correlations of events must be in the correct interval")
}else if( 0 > alpha || alpha > 1){
stop("Alpha value must be number between 0 and 1")
}else if( 0 > beta || beta > 1){
stop("Beta value must be number between 0 and 1")
}else if(unpooled != "unpooled Variance" && unpooled != "Pooled Variance"){
stop("You must choose between pooled and unpooled variance")
}
p0_CBE = 1- (1-p0_e1)*(1-p0_e2)*( 1+ rho*sqrt(p0_e1*p0_e2/((1-p0_e1)*(1-p0_e2)) ))
p1_CBE = 1- (1-p1_e1)*(1-p1_e2)*( 1+ rho*sqrt(p1_e1*p1_e2/((1-p1_e1)*(1-p1_e2)) ))
if(effect_ce == "rr"){
rr_CBE <- effect_ce(p0_e1, p0_e2, p1_e1, p1_e2, rho, type = "rr")
if(unpooled =="unpooled Variance"){
samp = 2*(((qnorm(1-alpha,0,1)+qnorm(1-beta,0,1))/(log(rr_CBE)))^2*( (1-rr_CBE*p0_CBE)/(rr_CBE*p0_CBE) + (1-p0_CBE)/p0_CBE))
}else if(unpooled =="Variance"){
p = (rr_CBE*p0_CBE + p0_CBE)/2
# sample size per group
samp = 2*(( (qnorm(1-alpha,0,1)* sqrt(2*(1-p)/p) + qnorm(1-beta,0,1)* sqrt( (1-rr_CBE*p0_CBE)/(rr_CBE*p0_CBE) + (1-p0_CBE)/p0_CBE) )/(log(rr_CBE)) )^2  )
}
}else if(effect_ce == "or"){
or_CBE = effect_ce(p0_e1, p0_e2, p1_e1, p1_e2, rho, type = "or")
p1 = (or_CBE*p0_CBE/(1-p0_CBE))/(1+(or_CBE*p0_CBE/(1-p0_CBE)))
if(unpooled=="unpooled Variance"){
samp = ((qnorm(1-alpha,0,1)+qnorm(1-beta,0,1))/(log(or_CBE)))^2*( 1/(p0_CBE*(1-p0_CBE)) + 1/(p1*(1-p1)) )
}else{
samp = ((qnorm(1-alpha,0,1)* sqrt(2/(((p1 + p0_CBE)/2)*(1-((p1 + p0_CBE)/2)))) + qnorm(1-beta,0,1)* sqrt(1/(p0_CBE*(1-p0_CBE)) + 1/(p1*(1-p1))))/(log(or_CBE)))^2
}
}else if(unpooled =="Variance"){
diff_CBE <- effect_ce(p0_e1, p0_e2, p1_e1, p1_e2, rho, type = "rr")
if(unpooled=="unpooled Variance"){
samp = ((qnorm(1-alpha,0,1) +qnorm(1-beta,0,1))/diff_CBE)^2*( p0_CBE*(1-p0_CBE) + (diff_CBE+p0_CBE)*(1-p0_CBE-diff_CBE))
}else if(unpooled=="Variance"){
p = (diff_CBE + 2 * p0_CBE)/2
# sample size per group
samp = ((qnorm(1-alpha,0,1)* sqrt(2*p*(1-p)) +  qnorm(1-beta,0,1)* sqrt( p0_CBE*(1-p0_CBE) + (diff_CBE+p0_CBE)*(1-p0_CBE-diff_CBE)))/diff.CBE)^2
}
}
return(samp)
}
#' @export
#'
#' @return Returns the probability of a union of two events
#' @details Returns a numeric value. The input parameters representing the probability of the events
#' taking place are limited between 0 and 1, without including both values. Pearson's correlation
#' must be within the confidence interval that allows the combined variable according to the probabilities given.
#' To calculate this confidence interval you can use lower_corr and upper_corr functions that you can find in this package.
#' @references M.Bofill , G.Gomez , A new approach for sizing trials with composite binary endpoints using anticipated marginal values and accounting for the correlation between components, http://cinna.upc.edu:3838/compare/compareCover/
#' @author Raquel Rovira Salvat
#'
prob_ce <- function(p_e1, p_e2, rho){
if(p_e1 < 0 || p_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p_e2 < 0 || p_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else if(rho < lower_corr(p_e1,p_e2)  ||  rho > upper_corr(p_e1,p_e2)){
stop("The correlations of events must be in the correct interval")
}else{
prob_ce <- 1- (1-p_e1)*(1-p_e2)*( 1+ rho*sqrt(p_e1*p_e2/((1-p_e1)*(1-p_e2))))
return(prob_ce)
}
}
prob_ce(0.3,0.2)
prob_ce(0.3,0.2,0.5)
prob_ce(0.3,0.2,0.8)
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#'
#' @export
#'
#' @return Returns the lower correlation threshold that the binominal compost event can reach
#' @details lower_corr returns a numeric value negated bounded between -1 and 0.
#' The probabilities of the occurrence of events must be defined by the open interval of (0.1).
#' @references M.Bofill , G.Gomez , A new approach for sizing trials with composite binary endpoints using anticipated marginal values and accounting for the correlation between components, http://cinna.upc.edu:3838/compare/compareCover/
#' @author Raquel Rovira Salvat
lower_corr <- function(p_e1,p_e2){
if(p_e1 < 0 || p_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p_e2 < 0 || p_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else{
lower_corr <- max(  -sqrt(p_e1*p_e2/((1-p_e1)*(1-p_e2))), -sqrt(((1-p_e1)*(1-p_e2))/(p_e1*p_e2)  ) )
return(lower_corr)
}
}
#' @param p_e1 numeric parameter, probability of the event E1
#' @param p_e2 numeric parameter, probability of the event E2
#'
#' @export
#'
#' @return Returns the upper correlation threshold that can be set by the compost binarius event.
#' @details upper_corr returns a numeric value negated bounded between 0 and 1.
#' The probabilities of the occurrence of events must be defined by the open interval of (0.1).
#' @references M.Bofill , G.Gomez , A new approach for sizing trials with composite binary endpoints using anticipated marginal values and accounting for the correlation between components, http://cinna.upc.edu:3838/compare/compareCover/
#' @author Raquel Rovira Salvat
upper_corr <- function(p_e1,p_e2){
if(p_e1 < 0 || p_e1 > 1){
stop("The probability of observing the event E1 (p_e1) must be number between 0 and 1")
}else if(p_e2 < 0 || p_e2 > 1){
stop("The probability of observing the event E2 (p_e2) must be number between 0 and 1")
}else{
upper_corr <- min(  sqrt( ( p_e1/ (1-p_e1) )/( p_e2/ (1-p_e2) ) ), sqrt((p_e2/(1-p_e2))/(p_e1/(1-p_e1)) ) )
return(upper_corr)
}
}
prob_ce(0.3,0.2,0.8)
prob_ce(0.3,0.2,0.5)
prob_ce(0.8,0.32,0.6)
prob_ce(0.8,0.32,0.7)
prob_ce(0.8,0.32,0.4)
prob_ce(0.8,0.32,0.1)
upper_corr(0.3,0.6)
upper_corr(0.9,0.5)
lower_corr
lower_corr(0.3,0.12)
lower_corr(0.3,0.9)
